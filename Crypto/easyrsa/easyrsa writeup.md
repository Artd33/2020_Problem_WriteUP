使用yafu对n进行大数分解

e与phi不互素，无法使用私钥d直接进行解密

设gcd(e,phi)=b，e=a*b

abd ≡1 mod phi

m^ab^ ≡ c mod n

c^bd^ ≡ m^abbd^ ≡ m^b^ mod n

解密后c'=m^2^ mod n

开方即可得到明文

```python
import gmpy2
from Crypto.Util.number import *
n = 155518463830560229644846724430836428995845620193574592170433241574666037137716528324571815369167049698698516255775616801764899976254095759074631817355320858739910069040009294893001147604941091673096339767232941480642397698104905644129961998649010457389845481973721204305241567277478343102339335893707164544801
p = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633547
q = 12470704223521630361963826771946763220892587623191431207923413178791149916874153397100361890510496084700189763294677638398021009427510131598570281465633283
e = 0x20002
c = 69775954010477827342655007357413905879265207201140046408669586721885526123784907133716642304622235420317538384169817488136355157658329703705226141938991105912868209447036610553660972001461632840370922684108791263764483626927583087998066070299767122268085587208956687449243493403662943691619787801332549149107
phin = (p - 1) * (q - 1)
b_d = gmpy2.invert(e // gmpy2.gcd(e, phin), phin)
m_2 = pow(c, b_d, n)
m=gmpy2.iroot(m_2,2)[0]
print(long_to_bytes(m))
```

flag: HECTF{ee709277385739acecbf0ebb06f0717b}

